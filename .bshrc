# Default BSH Startup Script (.bshrc) - Rewritten for New Operator Handling
# Executed when bsh starts. Defines core functions and aliases.
# Default BSH Startup Script (.bshrc) - Enhanced
# Executed when bsh starts. Defines core functions and aliases.
echo "Executing .bshrc (new operator model)..." #
echo "Welcome to bsh - The Extensible Shell!"
echo "------------------------------------"

# --- Core Settings & Aliases ---
$PS1 = "bsh-dyn" # Prompt reflecting dynamic operators
# Define some keyword aliases using the 'defkeyword' C-level command
defkeyword defunc function  # Alias 'defunc' to 'function' [cite: 4]
# defkeyword if when # 'when' alias example [cite: 4]

echo "Defined keyword aliases: 'function' for 'defunc'." #

# --- Import Core Framework Modules ---
# Assumes modules are in a directory accessible via BSH_MODULE_PATH.
# Sub-paths can be accessed using dots, e.g., framework.c_compiler.

echo "Importing c_compiler module..." #
import c_compiler # Provides def_c_lib [cite: 5]

echo "Importing core_operators module (defines operators and __dynamic_op_handler)..." #
import core_operators # NEW: Defines ops via 'defoperator' and __dynamic_op_handler [cite: 5]

echo "Importing string module..." #
import string # Assumed for string utilities [cite: 5]

echo "Importing number module (provides math actions)..." #
import number # Provides math_add, bsh_unary_*, etc. [cite: 5]

echo "Importing type module (for type system, if used by __dynamic_op_handler advanced forms)..." #
import type # For type checking, potentially [cite: 5]

echo "------------------------------------"

# --- Utility Functions (Leveraging Lexical Scoping) ---

# Function to check if a variable's value is empty.
# Usage: is_empty VAR_NAME_STRING RESULT_VAR_NAME
function is_empty (var_name_str result_var) { # [cite: 7]
    $temp_val = $($var_name_str)
    if $temp_val == "" {
        $($result_var) = "true"
    } else {
        $($result_var) = "false"
    }
}

# Function to demonstrate local scope
function scope_test (param1) {
    echo "--- scope_test ---"
    echo "Param1 (local): $param1"
    $local_var = "I am local to scope_test"
    echo "Local_var (local): $local_var"

    is_empty param1 param_empty_res
    echo "Is param1 empty? $param_empty_res" # [cite: 7, 8]
    echo "Global_var (from scope_test): $global_var_example"
    echo "--- end scope_test ---"
}

# --- Enhanced Control Structures ---
# for_loop and c_for can remain largely the same as they use inc/dec or command execution.
# The 'inc' and 'dec' keywords in bsh.c would now internally use the
# __dynamic_op_handler for $var++ like logic if they were implemented that way,
# or they might directly modify variables if they are simpler builtins.
# Assuming 'inc $varname' and 'dec $varname' are simple builtins that directly
# call math_add/math_sub on the variable's value and re-set it.

function for_loop (iterator start_val end_val step command_body) { # [cite: 8]
    echo "FOR_LOOP: Iter '$iterator' from $start_val to $end_val (exclusive) step $step"
    $($iterator) = $start_val

    if $step == "0" { # [cite: 8]
        echo "FOR_LOOP Error: Step value cannot be zero."
        return # [cite: 9]
    }

    # Condition evaluation (e.g., $($iterator) < $end_val) will now go through __dynamic_op_handler
    # if '<' is defined as an operator.
    # The inc/dec calls on iterator also go through the new mechanism.
    # For simplicity, let's assume inc/dec still work as commands or are handled.
    # If inc/dec are BSH functions that call, e.g., `VAR=$($VAR + 1)`, that will use the new op handling.

    $is_positive_step = "1" # Using "1" for true, "0" for false to align with math_gt etc.
    #math_gt "$step" "0" step_is_pos_res # Example if math_gt sets a var
    #if $step_is_pos_res == "0" { $is_positive_step = "0" }
    # Simplified for now, assuming string comparison works for simple positive/negative numbers
    if $step < "0" { # This comparison now uses __dynamic_op_handler [cite: 9]
        $is_positive_step = "0"
    }

    if $is_positive_step == "1" {
        while $($iterator) < $end_val { # Comparison uses __dynamic_op_handler
            $command_body
            # Simple increment using the $iterator itself via __dynamic_op_handler
            # This assumes 'inc' keyword or direct math can modify iterator based on step.
            # For loop: $iterator = $($iterator) + $step
            math_add "$($iterator)" "$step" "$iterator" # Re-assign to iterator
        }
    } else { # Negative step
        while $($iterator) > $end_val { # Comparison uses __dynamic_op_handler
            $command_body
            math_add "$($iterator)" "$step" "$iterator" # Step is negative, so this subtracts
        }
    }
    echo "FOR_LOOP: Finished for '$iterator'."
}


# --- JSON Handling (Conceptual Wrappers) ---
# This part remains conceptual. If bsh.c now flattens JSON, these functions would
# provide a BSH API to access those flattened variables.
function json_get (base_json_var_name path_str result_var_name) { # [cite: 22]
    echo "JSON_GET: Attempting to get path '$path_str' from flattened JSON var '$base_json_var_name'"

    # Assuming bsh.c created variables like:
    # $base_json_var_name_TYPE = "JSON_OBJECT" or "JSON_ARRAY"
    # $base_json_var_name_key = "value"
    # $base_json_var_name_object_subkey = "another_value"
    # $base_json_var_name_array_0 = "item1"
    # $base_json_var_name_array_length = "3"

    # This BSH function needs to parse path_str (e.g., "key.subkey" or "array[0]")
    # and construct the mangled variable name.
    # Example for "key.subkey":
    $mangled_var_name = "${base_json_var_name}_${path_str}" # Needs robust path to var name conversion
    # Crude replacement for dot in path with underscore for flattened var access:
    # (Requires a string replace function)
    # string_replace "$path_str" "." "_" path_as_var_suffix
    # $mangled_var_name = "${base_json_var_name}_$path_as_var_suffix"

    if $(is_var_defined $mangled_var_name) { # is_var_defined would be a new helper
        $($result_var_name) = $($mangled_var_name)
    } else {
        $($result_var_name) = "JSON_PATH_NOT_FOUND"
    }
    # This is highly simplified. A real json_get would need robust path parsing.
}

# --- Path Manipulation Example ---
# Stays largely the same, relies on shell's variable handling. [cite: 24]

# --- C Code Definition for bshmath ---
# This part is still crucial for number.bsh to function if it uses 'bshmath'.
$bsh_math_c_code = "
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

// Functions like bsh_add_numbers, bsh_subtract_numbers, etc. remain unchanged
// ... (all the C functions: bsh_add_numbers ... bsh_is_float) ...
int bsh_add_numbers(int argc, char* argv[], char* obuf, int obuf_size) {
  if (argc < 2) { snprintf(obuf, obuf_size, \"Error: Expected 2 numbers\"); return 1; }
  char *endptr1, *endptr2;
  double n1 = strtod(argv[0], &endptr1);
  double n2 = strtod(argv[1], &endptr2);
  if (*endptr1 != '\\0' || *endptr2 != '\\0') { snprintf(obuf, obuf_size, \"Error: Invalid number format\"); return 2; }
  snprintf(obuf, obuf_size, \"%g\", n1 + n2);
  return 0;
}
// ... (all other C math functions from original bshrc.txt)
int bsh_subtract_numbers(int argc, char* argv[], char* obuf, int obuf_size) { /* ... */ return 0;}
int bsh_multiply_numbers(int argc, char* argv[], char* obuf, int obuf_size) { /* ... */ return 0;}
int bsh_divide_numbers(int argc, char* argv[], char* obuf, int obuf_size) { /* ... */ return 0;}
int bsh_modulo_numbers(int argc, char* argv[], char* obuf, int obuf_size) { /* ... */ return 0;}
int bsh_is_integer(int argc, char* argv[], char* obuf, int obuf_size) { /* ... */ return 0;}
int bsh_is_float(int argc, char* argv[], char* obuf, int obuf_size) { /* ... */ return 0;}
// New: BSH needs a way to call the logical not on "0" or "1" if it was in C
// This bsh_logical_not was assumed in number.bsh
int bsh_logical_not(int argc, char* argv[], char* obuf, int obuf_size) {
  if (argc < 1) { snprintf(obuf, obuf_size, \"1\"); return 1; } // Default to true if no arg? Or error.
  if (strcmp(argv[0], \"0\") == 0 || strcmp(argv[0], \"false\") == 0 || argv[0][0] == '\\0') {
    snprintf(obuf, obuf_size, \"1\"); // true
  } else {
    snprintf(obuf, obuf_size, \"0\"); // false
  }
  return 0;
}
"

echo "Defining and compiling 'bshmath' C library for number framework..."
# Assumes c_compiler.def_c_lib is available [cite: 31]
def_c_lib bshmath bsh_math_c_code "" ""

if $bshmath_COMPILE_STATUS == "success" {
    if $bshmath_LOAD_STATUS == "success" {
        echo "'bshmath' library compiled and loaded successfully."
    } else {
        echo "Warning: 'bshmath' compiled but failed to load." # [cite: 57]
    }
} else {
    echo "Error: Failed to compile 'bshmath' library." # [cite: 58, 59]
}
echo "------------------------------------"

# --- End of .bshrc ---
echo ".bshrc execution finished." # [cite: 29]
echo ""

$global_var_example = "I am a global variable set in .bshrc" # [cite: 30]