# Default BSH Startup Script (.bshrc) - Enhanced
# Executed when bsh starts. Defines core functions and aliases.

echo "Executing .bshrc (v0.5 compatible)..."
echo "Welcome to bsh - The Extensible Shell!"
echo "------------------------------------"

# --- Core Settings & Aliases ---
$PS1 = "bsh-lex" # Prompt showing off lexical scope era!

# Define some keyword aliases using the new 'defkeyword' C-level command
defkeyword defunc function  # Alias 'defunc' to 'function'
defkeyword if     when    # Alias 'if' to 'when' (just an example)

echo "Defined keyword aliases: 'function' for 'defunc', 'when' for 'if'."

# Import core framework modules
# Assumes c_compiler.bsh and number.bsh are in a 'framework' directory
# accessible via BSH_MODULE_PATH (e.g., ./framework/c_compiler.bsh)

echo "Importing c_compiler module (framework.c_compiler)..."
import framework.c_compiler #todo: check if framework. suffix is needed

import core_operators

import framework.string

echo "Importing number module (framework.number)..."
import framework.number

import type

echo "------------------------------------"

# --- Utility Functions (Leveraging Lexical Scoping) ---

# Function to check if a variable's value is empty.
# Usage: is_empty VAR_NAME_STRING RESULT_VAR_NAME
# RESULT_VAR_NAME will be set to "true" or "false" in the caller's scope.
function is_empty (var_name_str result_var) {
    $temp_val = $($var_name_str)
    if $temp_val == "" {
        $($result_var) = "true"
    } else {
        $($result_var) = "false"
    }
}

# Function to demonstrate local scope
function scope_test (param1) {
    echo "--- scope_test ---"
    echo "Param1 (local): $param1"
    $local_var = "I am local to scope_test"
    echo "Local_var (local): $local_var"

    is_empty param1 param_empty_res
    echo "Is param1 empty? $param_empty_res"
    echo "Global_var (from scope_test): $global_var_example"
    echo "--- end scope_test ---"
}

# --- Enhanced Control Structures ---

# Define a 'for_loop' function
# Usage: for_loop ITERATOR_VAR_NAME START_VAL END_VAL_EXCLUSIVE STEP_VAL "COMMAND_STRING_TO_EXECUTE"
function for_loop (iterator start_val end_val step command_body) {
    echo "FOR_LOOP: Iter '$iterator' from $start_val to $end_val (exclusive) step $step"
    $($iterator) = $start_val

    if $step == "0" {
        echo "FOR_LOOP Error: Step value cannot be zero."
        return
    }

    $is_positive_step = "true"
    if $step < "0" { # Relies on shell's comparison logic
        $is_positive_step = "false"
    }

    if $is_positive_step == "true" {
        while $($iterator) < $end_val {
            $command_body
            $counter_for_step = "0"
            while $counter_for_step < $step {
                inc $($iterator)
                inc counter_for_step
            }
        }
    } else { # Negative step
        # Simplified negative step: effectively step -1 for each iteration of the outer loop.
        # A robust solution for arbitrary negative steps needs an 'abs' function or better string math.
        # Example: if step is "-2", this loop will dec by 1 twice for each outer iteration.
        # This part needs careful thought if arbitrary negative steps are critical.
        # For now, we make abs_step_val positive.
        $abs_step_val = $step # e.g. "-2"
        if $is_positive_step == "false" {
             # Crude way to get positive version for loop count
             if $step == "-1" { $abs_step_val = "1" }
             else if $step == "-2" { $abs_step_val = "2" }
             else if $step == "-3" { $abs_step_val = "3" }
             # Add more or use a string manipulation lib call if available:
             # $(calllib string_lib remove_prefix $step "-" abs_step_val)
             else { echo "FOR_LOOP: Warning - large negative steps might not work as expected without 'abs'."; $abs_step_val = "1"; } # Fallback
        }

        while $($iterator) > $end_val {
            $command_body
            $counter_for_step = "0"
            while $counter_for_step < $abs_step_val {
                 dec $($iterator)
                 inc counter_for_step
            }
        }
    }
    echo "FOR_LOOP: Finished for '$iterator'."
}

# Helper functions for C-style for loop conditions
function is_lt (op1 op2 result_var_name) { # op1 < op2 ?
    if $op1 < $op2 { $($result_var_name) = "true" } else { $($result_var_name) = "false" }
}
function is_le (op1 op2 result_var_name) { # op1 <= op2 ?
    if $op1 <= $op2 { $($result_var_name) = "true" } else { $($result_var_name) = "false" }
}

# Function for C-style for loop.
# Usage: c_for "INIT_CMD" "CONDITION_CMD" "COND_RESULT_VAR_NAME" "INCREMENT_CMD" "BODY_CMD"
function c_for (init_command condition_command condition_result_var increment_command body_command) {
    echo "C_FOR: Initializing..."
    $init_command
    echo "C_FOR: Starting loop..."
    $condition_command
    while $($condition_result_var) == "true" {
        $body_command
        $increment_command
        $condition_command
    }
    echo "C_FOR: Finished."
}

# --- JSON Handling (Conceptual Wrappers - relies on number.bsh/c_compiler.bsh loaded libs) ---
function json_get (json_var_name path_str result_var_name) {
    echo "JSON_GET: Attempting to get path '$path_str' from JSON in variable '$json_var_name'"
    $json_string_content = $($json_var_name)

    # This would ideally call a function from a JSON library loaded via c_compiler.bsh
    # For example, if 'jsonlib' was compiled and loaded, and has a 'get_path' function:
    # calllib jsonlib get_path "$json_string_content" "$path_str"
    # $($result_var_name) = $LAST_LIB_CALL_OUTPUT
    # if $LAST_LIB_CALL_STATUS != "0" { $($result_var_name) = "JSON_ERROR" }

    # Simulation for now:
    if $json_var_name == "my_sample_json" {
        if $path_str == ".name" { $($result_var_name) = "SimulatedBSHName" }
        else if $path_str == ".version" { $($result_var_name) = "Simulated0.5" }
        else { $($result_var_name) = "PATH_NOT_FOUND_IN_SIMULATED_JSON" }
    } else {
        echo "JSON_GET: (Conceptual) Would call external tool/library for JSON in '$json_var_name'."
        $($result_var_name) = "NOT_IMPLEMENTED_FOR_GENERAL_JSON"
    }
}

# --- Path Manipulation Example ---
function add_to_path (new_dir_to_add) {
    echo "ADD_TO_PATH: Adding '$new_dir_to_add' to PATH if not present."
    $current_path = $PATH # Get current PATH (shell variable)

    # Basic check to avoid simple duplicates - a robust solution is harder in pure script
    $temp_path_for_check = ":$current_path:"
    $dir_to_check1 = ":$new_dir_to_add:"
    $dir_to_check2 = "$new_dir_to_add:" # Start of path
    $dir_to_check3 = ":$new_dir_to_add"  # End of path

    # This string 'contains' check is conceptual without a built-in or lib function
    # if $(string_contains "$temp_path_for_check" "$dir_to_check1") == "true" {
    #    echo "'$new_dir_to_add' seems to be already in PATH."
    #    return
    # }
    # A simple, less robust check:
    if $current_path == $new_dir_to_add { # Only handles if PATH has one entry
         echo "'$new_dir_to_add' is already the only entry in PATH."
         return
    }


    if $current_path == "" {
        $PATH = $new_dir_to_add
    } else {
        $PATH = "$new_dir_to_add:$current_path" # Prepend
    }
    echo "ADD_TO_PATH: New PATH: $PATH"
    # Note: This updates the shell's $PATH variable.
    # To affect external commands, the C core would need to re-parse this $PATH
    # or the environment variable "PATH" would need to be updated via setenv (if bsh supports that).
}


# --- End of .bshrc ---
echo "------------------------------------"
echo ".bshrc execution finished. Frameworks (c_compiler, number) imported."
echo ""

# Example of setting a global variable for scope_test
$global_var_example = "I am a global variable set in .bshrc"

# Example: Define some C code for the number.bsh framework to use
# This should ideally be done *after* number.bsh is imported, if number.bsh
# itself doesn't define a default C math lib.
# For now, let's assume number.bsh expects 'bshmath' to be available.

$bsh_math_c_code = "
#include <stdio.h>
#include <stdlib.h> // For strtod, strtol
#include <string.h> // For snprintf
#include <math.h>   // For fmod (if needed for modulo on doubles)

// Expected signature: int func(int argc, char* argv[], char* obuf, int obuf_size)

int bsh_add_numbers(int argc, char* argv[], char* obuf, int obuf_size) {
  if (argc < 2) { snprintf(obuf, obuf_size, \"Error: Expected 2 numbers\"); return 1; }
  char *endptr1, *endptr2;
  double n1 = strtod(argv[0], &endptr1);
  double n2 = strtod(argv[1], &endptr2);
  if (*endptr1 != '\\0' || *endptr2 != '\\0') { snprintf(obuf, obuf_size, \"Error: Invalid number format\"); return 2; }
  snprintf(obuf, obuf_size, \"%g\", n1 + n2); // %g for general float format
  return 0;
}

int bsh_subtract_numbers(int argc, char* argv[], char* obuf, int obuf_size) {
  if (argc < 2) { snprintf(obuf, obuf_size, \"Error: Expected 2 numbers\"); return 1; }
  char *endptr1, *endptr2;
  double n1 = strtod(argv[0], &endptr1);
  double n2 = strtod(argv[1], &endptr2);
  if (*endptr1 != '\\0' || *endptr2 != '\\0') { snprintf(obuf, obuf_size, \"Error: Invalid number format\"); return 2; }
  snprintf(obuf, obuf_size, \"%g\", n1 - n2);
  return 0;
}

int bsh_multiply_numbers(int argc, char* argv[], char* obuf, int obuf_size) {
  if (argc < 2) { snprintf(obuf, obuf_size, \"Error: Expected 2 numbers\"); return 1; }
  char *endptr1, *endptr2;
  double n1 = strtod(argv[0], &endptr1);
  double n2 = strtod(argv[1], &endptr2);
  if (*endptr1 != '\\0' || *endptr2 != '\\0') { snprintf(obuf, obuf_size, \"Error: Invalid number format\"); return 2; }
  snprintf(obuf, obuf_size, \"%g\", n1 * n2);
  return 0;
}

int bsh_divide_numbers(int argc, char* argv[], char* obuf, int obuf_size) {
  if (argc < 2) { snprintf(obuf, obuf_size, \"Error: Expected 2 numbers\"); return 1; }
  char *endptr1, *endptr2;
  double n1 = strtod(argv[0], &endptr1);
  double n2 = strtod(argv[1], &endptr2);
  if (*endptr1 != '\\0' || *endptr2 != '\\0') { snprintf(obuf, obuf_size, \"Error: Invalid number format\"); return 2; }
  if (n2 == 0.0) { snprintf(obuf, obuf_size, \"Error: Division by zero\"); return 3; }
  snprintf(obuf, obuf_size, \"%g\", n1 / n2);
  return 0;
}

// For integer modulo with long
int bsh_modulo_numbers(int argc, char* argv[], char* obuf, int obuf_size) {
  if (argc < 2) { snprintf(obuf, obuf_size, \"Error: Expected 2 integers\"); return 1; }
  char *endptr1, *endptr2;
  long n1 = strtol(argv[0], &endptr1, 10);
  long n2 = strtol(argv[1], &endptr2, 10);
  if (*endptr1 != '\\0' || *endptr2 != '\\0') { snprintf(obuf, obuf_size, \"Error: Invalid integer format\"); return 2; }
  if (n2 == 0) { snprintf(obuf, obuf_size, \"Error: Modulo by zero\"); return 3; }
  snprintf(obuf, obuf_size, \"%ld\", n1 % n2);
  return 0;
}

// Type checking functions
int bsh_is_integer(int argc, char* argv[], char* obuf, int obuf_size) {
  if (argc < 1) { snprintf(obuf, obuf_size, \"false\"); return 1; }
  char *endptr;
  strtol(argv[0], &endptr, 10); // Attempt to convert
  if (argv[0][0] != '\\0' && *endptr == '\\0') snprintf(obuf, obuf_size, \"true\"); // Non-empty and all chars consumed
  else snprintf(obuf, obuf_size, \"false\");
  return 0;
}

int bsh_is_float(int argc, char* argv[], char* obuf, int obuf_size) {
  if (argc < 1) { snprintf(obuf, obuf_size, \"false\"); return 1; }
  char *endptr;
  strtod(argv[0], &endptr); // Attempt to convert
  if (argv[0][0] != '\\0' && *endptr == '\\0') snprintf(obuf, obuf_size, \"true\"); // Non-empty and all chars consumed
  else snprintf(obuf, obuf_size, \"false\");
  return 0;
}
"

# Now, use the imported c_compiler framework to make 'bshmath' available
# This assumes c_compiler.def_c_lib is available after import.
# The import mechanism should make functions from imported scripts available,
# possibly prefixed or directly. For now, assume direct availability if not namespaced.
echo "Defining and compiling 'bshmath' C library for number framework..."
def_c_lib bshmath bsh_math_c_code "" "" # No special CFLAGS or LDFLAGS for this example

if $bshmath_COMPILE_STATUS == "success" {
    if $bshmath_LOAD_STATUS == "success" {
        echo "'bshmath' library compiled and loaded successfully for number operations."
    } else {
        echo "Warning: 'bshmath' compiled but failed to load. Math functions in number.bsh may not work."
    }
} else {
    echo "Error: Failed to compile 'bshmath' library. Math functions in number.bsh will not work."
}
echo "------------------------------------"

