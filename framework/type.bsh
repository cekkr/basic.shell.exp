# type.bsh
echo "Loading Type Framework (type.bsh)..."

# Assumes number.bsh's math_is_int and math_is_float are loaded and available.
# This implies careful ordering in your main startup script (.bshrc).

# Function to determine the type of a given string value.
# result_var_name will be set to "INTEGER", "FLOAT", or "STRING".
function get_type (value_str result_var_name) {
    $temp_is_int = "0"
    math_is_int "$value_str" temp_is_int # [cite: 11]

    if $temp_is_int == "1" {
        $($result_var_name) = "INTEGER"
        return
    }

    $temp_is_float = "0"
    math_is_float "$value_str" temp_is_float # [cite: 12]
    if $temp_is_float == "1" {
        $($result_var_name) = "FLOAT"
        return
    }
    $($result_var_name) = "STRING" # Default type
}

# Registers a BSH function to handle a specific operator and type combination.
# Example: register_operator_handler "+" "INTEGER" "INTEGER" "my_integer_add_func"
function register_operator_handler (op_str type1_str type2_str handler_bsh_function_name) {
    $op_name_safe = $op_str
    # Sanitize operator characters for use in variable names if needed
    if $op_str == "+" { $op_name_safe = "PLUS" }
    else if $op_str == "-" { $op_name_safe = "MINUS" }
    else if $op_str == "*" { $op_name_safe = "MUL" }
    else if $op_str == "/" { $op_name_safe = "DIV" }
    else if $op_str == "%" { $op_name_safe = "MOD" }
    # Add other operators as necessary. The '.' operator is special [cite: 14, 16, 17, 19]
    # and can be registered too.
    else if $op_str == "." { $op_name_safe = "DOT" }


    $var_name = "BSH_OP_HANDLER_${op_name_safe}_${type1_str}_${type2_str}"
    $($var_name) = "$handler_bsh_function_name"
    # echo "Debug: Registered Op Handler: $var_name = $handler_bsh_function_name"
}

echo "Type Framework loaded."