# core_operators.bsh
# Defines standard operator symbols to the C tokenizer and provides the
# central BSH __dynamic_op_handler for processing them.
# Loaded by .bshrc

echo "Loading Core Operators Framework (core_operators.bsh)..."

# --- Define Core Operator Symbols for the C Tokenizer ---
# The 'defoperator' built-in tells bsh.c to recognize these strings as TOKEN_OPERATOR.
# The C tokenizer will then pass these strings to __dynamic_op_handler.

# Arithmetic and Decimal
defoperator "+"
defoperator "-"  # For subtraction. Negative numbers are handled by C tokenizer directly.
defoperator "*"
defoperator "/"
defoperator "%"
defoperator "."  # For decimal construction or other BSH-defined uses

# Unary Increment/Decrement
defoperator "++"
defoperator "--"

# Comparison (will be handled by __dynamic_op_handler and number.bsh)
defoperator "=="
defoperator "!="
defoperator ">"
defoperator "<"
defoperator ">="
defoperator "<="

# Logical (if not handled as special keywords by C parser for if/while)
# Assuming for now 'if ! var' is handled by 'if' keyword parsing the '!'
# If '!' is a general purpose logical NOT operator, it could be defined here too.
# defoperator "!"
# defoperator "&&"
# defoperator "||"

echo "Core operator symbols defined."

# --- Central Dynamic Operator Handler ---
# The C core (invoke_bsh_dynamic_op_handler) calls this BSH function when it encounters
# an operator in an expression (standalone or RHS of assignment).
#
# Signature from C: __dynamic_op_handler (arg1, arg2, arg3, result_holder_var_name)
#
# For Binary Operations (e.g., VAL1 + VAL2):
#   arg1: string value of the first operand (e.g., "10")
#   arg2: string value of the second operand (e.g., "5")
#   arg3: operator symbol string (e.g., "+")
#   result_holder_var_name: name of BSH var to store expression result (e.g., "__TEMP_OP_RES")
#
# For Unary Operations (e.g., ++VAR or VAR++):
#   arg1: name of the variable being operated on (e.g., "myCounter")
#   arg2: operator symbol string (e.g., "++")
#   arg3: context string ("prefix" or "postfix")
#   result_holder_var_name: name of BSH var to store expression result (e.g., "__TEMP_OP_RES")

function __dynamic_op_handler (param_arg1 param_arg2 param_arg3 param_result_var_name) {
    echo "BSH __dynamic_op_handler: Args <$param_arg1> <$param_arg2> <$param_arg3> -> $param_result_var_name"

    # Determine context: Unary or Binary
    if $param_arg3 == "prefix" {
        $op_var_name = "$param_arg1"
        $op_symbol = "$param_arg2"
        echo "BSH Dispatch: Unary Prefix: $op_symbol on var '$op_var_name'"

        if $op_symbol == "++" {
            bsh_unary_prefix_increment "$op_var_name" $param_result_var_name # From number.bsh
        } else if $op_symbol == "--" {
            bsh_unary_prefix_decrement "$op_var_name" $param_result_var_name # From number.bsh
        } else {
            echo "Error (__dynamic_op_handler): Unknown unary prefix operator '$op_symbol'"
            $($param_result_var_name) = "UNKNOWN_PREFIX_OP_ERROR"
        }
        return
    } else if $param_arg3 == "postfix" {
        $op_var_name = "$param_arg1"
        $op_symbol = "$param_arg2"
        echo "BSH Dispatch: Unary Postfix: $op_symbol on var '$op_var_name'"

        if $op_symbol == "++" {
            bsh_unary_postfix_increment "$op_var_name" $param_result_var_name # From number.bsh
        } else if $op_symbol == "--" {
            bsh_unary_postfix_decrement "$op_var_name" $param_result_var_name # From number.bsh
        } else {
            echo "Error (__dynamic_op_handler): Unknown unary postfix operator '$op_symbol'"
            $($param_result_var_name) = "UNKNOWN_POSTFIX_OP_ERROR"
        }
        return
    }

    # Assume Binary Operation if context is not "prefix" or "postfix"
    # Here, param_arg3 is the operator symbol itself.
    $val1_str = "$param_arg1"
    $val2_str = "$param_arg2"
    $op_symbol_binary = "$param_arg3"
    echo "BSH Dispatch: Binary: '$val1_str' $op_symbol_binary '$val2_str'"

    # Here, a more sophisticated system might use the 'type.bsh' framework
    # to get types of val1_str and val2_str and dispatch to a registered handler
    # (like the old register_operator_handler system).
    # For this example, we'll do a direct switch based on the operator symbol,
    # calling functions from number.bsh.

    if $op_symbol_binary == "+" {
        math_add "$val1_str" "$val2_str" $param_result_var_name
    } else if $op_symbol_binary == "-" {
        math_sub "$val1_str" "$val2_str" $param_result_var_name
    } else if $op_symbol_binary == "*" {
        math_mul "$val1_str" "$val2_str" $param_result_var_name
    } else if $op_symbol_binary == "/" {
        math_div "$val1_str" "$val2_str" $param_result_var_name
    } else if $op_symbol_binary == "%" {
        math_mod "$val1_str" "$val2_str" $param_result_var_name
    } else if $op_symbol_binary == "." { # Decimal construction
        # This used to be in the 'calc' function.
        # Assumes val1 is integer part (can be empty), val2 is fractional part.
        if "$val1_str" == "" { # Handle cases like ".5" -> "0.5"
            $($param_result_var_name) = "0.$val2_str"
        } else {
            $($param_result_var_name) = "$val1_str.$val2_str"
        }
        echo "BSH Dispatch: Decimal construct '$val1_str.$val2_str' result: $($param_result_var_name)"
    } else if $op_symbol_binary == "==" {
        math_eq "$val1_str" "$val2_str" $param_result_var_name
    } else if $op_symbol_binary == "!=" {
        math_ne "$val1_str" "$val2_str" $param_result_var_name
    } else if $op_symbol_binary == ">" {
        math_gt "$val1_str" "$val2_str" $param_result_var_name
    } else if $op_symbol_binary == "<" {
        math_lt "$val1_str" "$val2_str" $param_result_var_name
    } else if $op_symbol_binary == ">=" {
        math_ge "$val1_str" "$val2_str" $param_result_var_name
    } else if $op_symbol_binary == "<=" {
        math_le "$val1_str" "$val2_str" $param_result_var_name
    } else {
        echo "Error (__dynamic_op_handler): Unknown or unsupported binary operator '$op_symbol_binary'"
        $($param_result_var_name) = "UNKNOWN_BINARY_OP_ERROR"
    }
}

echo "Core Operators Framework loaded. __dynamic_op_handler is defined."