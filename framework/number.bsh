# BSH Number Framework (number.bsh)
# Provides functions for mathematical operations on number-like strings.
# Assumes a C math library (e.g., compiled via c_compiler.bsh) is loaded,
# typically with an alias like 'bshmath'.
echo "Loading Number Framework (number.bsh)..."

# --- Configuration ---
$BSH_MATH_LIB_ALIAS = "bshmath"

# --- Helper: Check if the math library seems loaded ---
function is_math_lib_loaded (result_var) {
    echo "is_math_lib_loaded: Assuming '$BSH_MATH_LIB_ALIAS' is loaded if used."
    $($result_var) = "true" # Placeholder
}

# --- Core Math Operations (Wrappers for C library calls) ---
function _math_binary_op (op_display_name c_func_name arg1_str arg2_str result_var_name) {
    echo "MATH $op_display_name: $arg1_str, $arg2_str"
    is_math_lib_loaded math_lib_ready
    if $math_lib_ready != "true" {
        echo "Error: Math library '$BSH_MATH_LIB_ALIAS' not loaded. Cannot perform $op_display_name."
        $($result_var_name) = "MATH_LIB_ERROR"
        return
    }
    calllib $BSH_MATH_LIB_ALIAS $c_func_name "$arg1_str" "$arg2_str"
    if $LAST_LIB_CALL_STATUS == "0" {
        $($result_var_name) = $LAST_LIB_CALL_OUTPUT
        echo "MATH $op_display_name result: $($result_var_name)"
    } else {
        echo "Error during $op_display_name operation with $BSH_MATH_LIB_ALIAS.$c_func_name."
        echo "  Status: $LAST_LIB_CALL_STATUS, Output: $LAST_LIB_CALL_OUTPUT"
        $($result_var_name) = "OPERATION_ERROR"
    }
}

function math_add (num1_str num2_str result_var) {
    _math_binary_op "add" "bsh_add_numbers" "$num1_str" "$num2_str" $result_var
}

function math_sub (num1_str num2_str result_var) {
    _math_binary_op "subtract" "bsh_subtract_numbers" "$num1_str" "$num2_str" $result_var
}

function math_mul (num1_str num2_str result_var) {
    _math_binary_op "multiply" "bsh_multiply_numbers" "$num1_str" "$num2_str" $result_var
}

function math_div (num1_str num2_str result_var) {
    _math_binary_op "divide" "bsh_divide_numbers" "$num1_str" "$num2_str" $result_var
}

function math_mod (num1_str num2_str result_var) {
    _math_binary_op "modulo" "bsh_modulo_numbers" "$num1_str" "$num2_str" $result_var
}

# --- Helper for Comparison Operations ---
function _math_compare_op (op_display_name c_func_name arg1_str arg2_str result_var_name) {
    echo "MATH COMPARE $op_display_name: $arg1_str, $arg2_str"
    is_math_lib_loaded math_lib_ready
    if $math_lib_ready != "true" {
        echo "Error: Math library '$BSH_MATH_LIB_ALIAS' not loaded. Cannot perform $op_display_name."
        $($result_var_name) = "0" 
        return
    }
    calllib $BSH_MATH_LIB_ALIAS $c_func_name "$arg1_str" "$arg2_str"
    if $LAST_LIB_CALL_STATUS == "0" {
        $($result_var_name) = $LAST_LIB_CALL_OUTPUT 
        echo "MATH COMPARE $op_display_name result: $($result_var_name)"
    } else {
        echo "Error during $op_display_name operation with $BSH_MATH_LIB_ALIAS.$c_func_name."
        echo "  Status: $LAST_LIB_CALL_STATUS, Output: $LAST_LIB_CALL_OUTPUT"
        $($result_var_name) = "0" 
    }
}

# --- Comparison Functions ---
function math_eq (num1_str num2_str result_var) {
    _math_compare_op "equal" "bsh_numbers_equal" "$num1_str" "$num2_str" $result_var
}
function math_ne (num1_str num2_str result_var) {
    _math_compare_op "not_equal" "bsh_numbers_not_equal" "$num1_str" "$num2_str" $result_var
}
function math_gt (num1_str num2_str result_var) {
    _math_compare_op "greater_than" "bsh_numbers_greater_than" "$num1_str" "$num2_str" $result_var
}
function math_lt (num1_str num2_str result_var) {
    _math_compare_op "less_than" "bsh_numbers_less_than" "$num1_str" "$num2_str" $result_var
}
function math_ge (num1_str num2_str result_var) {
    _math_compare_op "greater_equal" "bsh_numbers_greater_equal" "$num1_str" "$num2_str" $result_var
}
function math_le (num1_str num2_str result_var) {
    _math_compare_op "less_equal" "bsh_numbers_less_equal" "$num1_str" "$num2_str" $result_var
}

# --- Logical NOT for "0" or "1" ---
function math_not (value_str result_var) {
    echo "MATH NOT: Inverting '$value_str'"
    is_math_lib_loaded math_lib_ready
    if $math_lib_ready != "true" {
        echo "Error: Math library '$BSH_MATH_LIB_ALIAS' not loaded for math_not."
        $($result_var) = "0" 
        return
    }
    calllib $BSH_MATH_LIB_ALIAS "bsh_logical_not" "$value_str"
    if $LAST_LIB_CALL_STATUS == "0" {
        $($result_var) = $LAST_LIB_CALL_OUTPUT 
    } else {
        echo "Error during math_not operation with $BSH_MATH_LIB_ALIAS.bsh_logical_not."
        echo "  Status: $LAST_LIB_CALL_STATUS, Output: $LAST_LIB_CALL_OUTPUT"
        $($result_var) = "0" 
    }
    echo "MATH NOT result for '$value_str': $($result_var)"
}

# --- Type Checking Functions ---
function math_is_int (value_str result_var) {
    echo "MATH is_int: Checking '$value_str'"
    calllib $BSH_MATH_LIB_ALIAS "bsh_is_integer" "$value_str"
    if $LAST_LIB_CALL_STATUS == "0" {
        $($result_var) = $LAST_LIB_CALL_OUTPUT
    } else {
        $($result_var) = "0" 
    }
    echo "MATH is_int result for '$value_str': $($result_var)"
}
function math_is_float (value_str result_var) {
    echo "MATH is_float: Checking '$value_str'"
    calllib $BSH_MATH_LIB_ALIAS "bsh_is_float" "$value_str"
    if $LAST_LIB_CALL_STATUS == "0" {
        $($result_var) = $LAST_LIB_CALL_OUTPUT
    } else {
        $($result_var) = "0"
    }
    echo "MATH is_float result for '$value_str': $($result_var)"
}

# --- Unified 'calc' function (Example of type-dependent operation) ---
# Updated to handle '.' as a decimal construction operator.
function calc (var1_name op_str var2_name result_var) {
    $val1 = $($var1_name)
    $val2 = $($var2_name)

    echo "CALC: Performing '$val1 $op_str $val2'"

    if $op_str == "+" {
        math_add "$val1" "$val2" $result_var
    } else if $op_str == "-" {
        math_sub "$val1" "$val2" $result_var
    } else if $op_str == "*" {
        math_mul "$val1" "$val2" $result_var
    } else if $op_str == "/" {
        math_div "$val1" "$val2" $result_var
    } else if $op_str == "%" {
        math_mod "$val1" "$val2" $result_var
    } else if $op_str == "." {
        # Decimal construction operator: forms a string like "val1.val2"
        # Assumes val1 is the integer part and val2 is the fractional part (digits only).
        # Example: calc my_int_var "." my_frac_var combined_float_var
        # If my_int_var=10 and my_frac_var=5, combined_float_var becomes "10.5"
        # If my_int_var=0 and my_frac_var=75, combined_float_var becomes "0.75"
        # If val1 is empty, it could be ".5" (though C functions might prefer "0.5")
        if $val1 == "" { # Handle cases like ".5" -> "0.5" for robustness with C math libs
            $($result_var) = "0.$val2"
        } else {
            $($result_var) = "$val1.$val2"
        }
        echo "CALC decimal construct '$val1.$val2' result: $($result_var)"
    } else {
        echo "CALC Error: Unsupported operator '$op_str'."
        $($result_var) = "CALC_OPERATOR_ERROR"
    }
}


# BSH wrapper handlers for core math operations.
# These adapt the existing math_* functions to the dispatcher's expected signature.
function bsh_core_math_add_handler (val1 type1 val2 type2 result_var) {
    # math_add (and underlying C bsh_add_numbers) is expected to:
    # 1. Parse string inputs val1, val2 to numbers.
    # 2. Handle integer + float promotion to float.
    # 3. Store string representation of the result in result_var.
    math_add "$val1" "$val2" $result_var
}
function bsh_core_math_sub_handler (val1 type1 val2 type2 result_var) {
    math_sub "$val1" "$val2" $result_var
}
function bsh_core_math_mul_handler (val1 type1 val2 type2 result_var) {
    math_mul "$val1" "$val2" $result_var
}
function bsh_core_math_div_handler (val1 type1 val2 type2 result_var) {
    math_div "$val1" "$val2" $result_var
}
function bsh_core_math_mod_handler (val1 type1 val2 type2 result_var) {
    math_mod "$val1" "$val2" $result_var
}
function bsh_decimal_constructor_handler (val1 type1 val2 type2 result_var) {
    # Implements the "val1.val2" decimal construction [cite: 16, 17]
    if "$val1" == "" { # Handle cases like ".5" -> "0.5"
        $($result_var) = "0.$val2"
    } else {
        $($result_var) = "$val1.$val2"
    }
}


# Register handlers (assuming type.bsh is already sourced)
register_operator_handler "+" "INTEGER" "INTEGER" "bsh_core_math_add_handler"
register_operator_handler "+" "FLOAT" "FLOAT" "bsh_core_math_add_handler"
register_operator_handler "+" "INTEGER" "FLOAT" "bsh_core_math_add_handler" # C lib handles promotion
register_operator_handler "+" "FLOAT" "INTEGER" "bsh_core_math_add_handler" # C lib handles promotion

register_operator_handler "-" "INTEGER" "INTEGER" "bsh_core_math_sub_handler"
# ... register for other combinations and other ops (sub, mul, div, mod) ...

# Register the '.' decimal constructor
# Typically, both parts are expected to be or represent numbers (digits).
register_operator_handler "." "INTEGER" "INTEGER" "bsh_decimal_constructor_handler"
register_operator_handler "." "STRING" "STRING" "bsh_decimal_constructor_handler" # e.g. "10" . "5"
register_operator_handler "." "INTEGER" "STRING" "bsh_decimal_constructor_handler"
register_operator_handler "." "STRING" "INTEGER" "bsh_decimal_constructor_handler"
register_operator_handler "." "" "STRING" "bsh_decimal_constructor_handler" # For ".5" type cases
register_operator_handler "." "" "INTEGER" "bsh_decimal_constructor_handler"

echo "Number Framework operator handlers registered."

# --- BSH Unary Operator Handlers ---
# These functions are called by the C core for $var++, ++$var, etc.

# BSH Function Signature: handler_name (var_to_modify_name_str, result_holder_var_name_str)
# - var_to_modify_name_str: The name of the variable (e.g., "myCounter") as a string.
# - result_holder_var_name_str: The name of a temporary BSH variable (e.g., "__TEMP_UNARY_OP_EXPR_RES")
#                               where this function should store the "value of the expression".

function __bsh_postfix_increment (target_var_name_str result_holder_var_name) {
    # Get the current value of the variable whose name is in target_var_name_str
    $original_value = $($target_var_name_str)

    # Perform increment (using existing math_add or a C lib call directly if preferred)
    math_add "$original_value" "1" __temp_inc_new_val # math_add stores result in its 3rd arg var name

    # Update the original variable itself using its name
    $($target_var_name_str) = $__temp_inc_new_val

    # For postfix, the "result of the expression" is the original value
    $($result_holder_var_name) = "$original_value"

    # Optional: echo for debugging or if standalone ops should print
    # echo "Postfix Inc: Variable '$target_var_name_str' was '$original_value', now '$($target_var_name_str)'. Expression value: '$original_value'."
}

function __bsh_prefix_increment (target_var_name_str result_holder_var_name) {
    $original_value = $($target_var_name_str)
    math_add "$original_value" "1" __temp_inc_new_val
    $($target_var_name_str) = $__temp_inc_new_val

    # For prefix, the "result of the expression" is the new value
    $($result_holder_var_name) = "$__temp_inc_new_val"

    # Optional: echo
    # echo "Prefix Inc: Variable '$target_var_name_str' was '$original_value', now '$($target_var_name_str)'. Expression value: '$($target_var_name_str)'."
}

function __bsh_postfix_decrement (target_var_name_str result_holder_var_name) {
    $original_value = $($target_var_name_str)
    math_sub "$original_value" "1" __temp_dec_new_val
    $($target_var_name_str) = $__temp_dec_new_val
    $($result_holder_var_name) = "$original_value"
}

function __bsh_prefix_decrement (target_var_name_str result_holder_var_name) {
    $original_value = $($target_var_name_str)
    math_sub "$original_value" "1" __temp_dec_new_val
    $($target_var_name_str) = $__temp_dec_new_val
    $($result_holder_var_name) = "$__temp_dec_new_val"
}

echo "Unary operator BSH handlers (__bsh_postfix_increment, etc.) defined."

echo "Number Framework loaded. '-' before digits may now be tokenized as part of a number by bsh.c."
echo "The '.' operator can be used in 'calc' for decimal construction (e.g., calc var1 \".\" var2 result)."
# --- Example Usage Update ---
# $my_neg_five = -5 # This should now work if bsh.c is updated
# echo "My negative five: $my_neg_five"
#
# $integer_part = 10
# $fractional_part = 75
# $constructed_float = ""
# calc integer_part "." fractional_part constructed_float
# echo "Constructed float via '.': $constructed_float" # Expected: 10.75
#
# $another_float = ""
# $zero = 0
# $frac = 5
# calc zero "." frac another_float
# echo "Another constructed float: $another_float" # Expected: 0.5
#
# # Test it with a math function that expects a float string
# math_add $constructed_float "1.25" total_sum
# echo "$constructed_float + 1.25 = $total_sum" # Expected: 12.00 (or 12.0 depending on C lib)