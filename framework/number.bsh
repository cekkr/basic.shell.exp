# BSH Number Framework (number.bsh)
# Provides functions for mathematical operations on number-like strings.
# Assumes a C math library (e.g., compiled via c_compiler.bsh) is loaded,
# typically with an alias like 'bshmath'.
echo "Loading Number Framework (number.bsh)..."

# --- Configuration ---
$BSH_MATH_LIB_ALIAS = "bshmath"

# --- Helper: Check if the math library seems loaded ---
function is_math_lib_loaded (result_var) {
    echo "is_math_lib_loaded: Assuming '$BSH_MATH_LIB_ALIAS' is loaded if used."
    $($result_var) = "true" # Placeholder
}

# --- Core Math Operations (Wrappers for C library calls) ---
function _math_binary_op (op_display_name c_func_name arg1_str arg2_str result_var_name) {
    echo "MATH $op_display_name: $arg1_str, $arg2_str"
    is_math_lib_loaded math_lib_ready
    if $math_lib_ready != "true" {
        echo "Error: Math library '$BSH_MATH_LIB_ALIAS' not loaded. Cannot perform $op_display_name."
        $($result_var_name) = "MATH_LIB_ERROR"
        return
    }
    calllib $BSH_MATH_LIB_ALIAS $c_func_name "$arg1_str" "$arg2_str"
    if $LAST_LIB_CALL_STATUS == "0" {
        $($result_var_name) = $LAST_LIB_CALL_OUTPUT
        echo "MATH $op_display_name result: $($result_var_name)"
    } else {
        echo "Error during $op_display_name operation with $BSH_MATH_LIB_ALIAS.$c_func_name."
        echo "  Status: $LAST_LIB_CALL_STATUS, Output: $LAST_LIB_CALL_OUTPUT"
        $($result_var_name) = "OPERATION_ERROR"
    }
}

function math_add (num1_str num2_str result_var) {
    _math_binary_op "add" "bsh_add_numbers" "$num1_str" "$num2_str" $result_var
}

function math_sub (num1_str num2_str result_var) {
    _math_binary_op "subtract" "bsh_subtract_numbers" "$num1_str" "$num2_str" $result_var
}

function math_mul (num1_str num2_str result_var) {
    _math_binary_op "multiply" "bsh_multiply_numbers" "$num1_str" "$num2_str" $result_var
}

function math_div (num1_str num2_str result_var) {
    _math_binary_op "divide" "bsh_divide_numbers" "$num1_str" "$num2_str" $result_var
}

function math_mod (num1_str num2_str result_var) {
    _math_binary_op "modulo" "bsh_modulo_numbers" "$num1_str" "$num2_str" $result_var
}

# --- Helper for Comparison Operations ---
function _math_compare_op (op_display_name c_func_name arg1_str arg2_str result_var_name) {
    echo "MATH COMPARE $op_display_name: $arg1_str, $arg2_str"
    is_math_lib_loaded math_lib_ready
    if $math_lib_ready != "true" {
        echo "Error: Math library '$BSH_MATH_LIB_ALIAS' not loaded. Cannot perform $op_display_name."
        $($result_var_name) = "0" 
        return
    }
    calllib $BSH_MATH_LIB_ALIAS $c_func_name "$arg1_str" "$arg2_str"
    if $LAST_LIB_CALL_STATUS == "0" {
        $($result_var_name) = $LAST_LIB_CALL_OUTPUT 
        echo "MATH COMPARE $op_display_name result: $($result_var_name)"
    } else {
        echo "Error during $op_display_name operation with $BSH_MATH_LIB_ALIAS.$c_func_name."
        echo "  Status: $LAST_LIB_CALL_STATUS, Output: $LAST_LIB_CALL_OUTPUT"
        $($result_var_name) = "0" 
    }
}

# --- Comparison Functions ---
function math_eq (num1_str num2_str result_var) {
    _math_compare_op "equal" "bsh_numbers_equal" "$num1_str" "$num2_str" $result_var
}
function math_ne (num1_str num2_str result_var) {
    _math_compare_op "not_equal" "bsh_numbers_not_equal" "$num1_str" "$num2_str" $result_var
}
function math_gt (num1_str num2_str result_var) {
    _math_compare_op "greater_than" "bsh_numbers_greater_than" "$num1_str" "$num2_str" $result_var
}
function math_lt (num1_str num2_str result_var) {
    _math_compare_op "less_than" "bsh_numbers_less_than" "$num1_str" "$num2_str" $result_var
}
function math_ge (num1_str num2_str result_var) {
    _math_compare_op "greater_equal" "bsh_numbers_greater_equal" "$num1_str" "$num2_str" $result_var
}
function math_le (num1_str num2_str result_var) {
    _math_compare_op "less_equal" "bsh_numbers_less_equal" "$num1_str" "$num2_str" $result_var
}

# --- Logical NOT for "0" or "1" ---
function math_not (value_str result_var) {
    echo "MATH NOT: Inverting '$value_str'"
    is_math_lib_loaded math_lib_ready
    if $math_lib_ready != "true" {
        echo "Error: Math library '$BSH_MATH_LIB_ALIAS' not loaded for math_not."
        $($result_var) = "0" 
        return
    }
    calllib $BSH_MATH_LIB_ALIAS "bsh_logical_not" "$value_str"
    if $LAST_LIB_CALL_STATUS == "0" {
        $($result_var) = $LAST_LIB_CALL_OUTPUT 
    } else {
        echo "Error during math_not operation with $BSH_MATH_LIB_ALIAS.bsh_logical_not."
        echo "  Status: $LAST_LIB_CALL_STATUS, Output: $LAST_LIB_CALL_OUTPUT"
        $($result_var) = "0" 
    }
    echo "MATH NOT result for '$value_str': $($result_var)"
}

# --- Type Checking Functions ---
function math_is_int (value_str result_var) {
    echo "MATH is_int: Checking '$value_str'"
    calllib $BSH_MATH_LIB_ALIAS "bsh_is_integer" "$value_str"
    if $LAST_LIB_CALL_STATUS == "0" {
        $($result_var) = $LAST_LIB_CALL_OUTPUT
    } else {
        $($result_var) = "0" 
    }
    echo "MATH is_int result for '$value_str': $($result_var)"
}
function math_is_float (value_str result_var) {
    echo "MATH is_float: Checking '$value_str'"
    calllib $BSH_MATH_LIB_ALIAS "bsh_is_float" "$value_str"
    if $LAST_LIB_CALL_STATUS == "0" {
        $($result_var) = $LAST_LIB_CALL_OUTPUT
    } else {
        $($result_var) = "0"
    }
    echo "MATH is_float result for '$value_str': $($result_var)"
}

# --- Unified 'calc' function (Example of type-dependent operation) ---
# Updated to handle '.' as a decimal construction operator.
function calc (var1_name op_str var2_name result_var) {
    $val1 = $($var1_name)
    $val2 = $($var2_name)

    echo "CALC: Performing '$val1 $op_str $val2'"

    if $op_str == "+" {
        math_add "$val1" "$val2" $result_var
    } else if $op_str == "-" {
        math_sub "$val1" "$val2" $result_var
    } else if $op_str == "*" {
        math_mul "$val1" "$val2" $result_var
    } else if $op_str == "/" {
        math_div "$val1" "$val2" $result_var
    } else if $op_str == "%" {
        math_mod "$val1" "$val2" $result_var
    } else if $op_str == "." {
        # Decimal construction operator: forms a string like "val1.val2"
        # Assumes val1 is the integer part and val2 is the fractional part (digits only).
        # Example: calc my_int_var "." my_frac_var combined_float_var
        # If my_int_var=10 and my_frac_var=5, combined_float_var becomes "10.5"
        # If my_int_var=0 and my_frac_var=75, combined_float_var becomes "0.75"
        # If val1 is empty, it could be ".5" (though C functions might prefer "0.5")
        if $val1 == "" { # Handle cases like ".5" -> "0.5" for robustness with C math libs
            $($result_var) = "0.$val2"
        } else {
            $($result_var) = "$val1.$val2"
        }
        echo "CALC decimal construct '$val1.$val2' result: $($result_var)"
    } else {
        echo "CALC Error: Unsupported operator '$op_str'."
        $($result_var) = "CALC_OPERATOR_ERROR"
    }
}

echo "Number Framework loaded. '-' before digits may now be tokenized as part of a number by bsh.c."
echo "The '.' operator can be used in 'calc' for decimal construction (e.g., calc var1 \".\" var2 result)."
# --- Example Usage Update ---
# $my_neg_five = -5 # This should now work if bsh.c is updated
# echo "My negative five: $my_neg_five"
#
# $integer_part = 10
# $fractional_part = 75
# $constructed_float = ""
# calc integer_part "." fractional_part constructed_float
# echo "Constructed float via '.': $constructed_float" # Expected: 10.75
#
# $another_float = ""
# $zero = 0
# $frac = 5
# calc zero "." frac another_float
# echo "Another constructed float: $another_float" # Expected: 0.5
#
# # Test it with a math function that expects a float string
# math_add $constructed_float "1.25" total_sum
# echo "$constructed_float + 1.25 = $total_sum" # Expected: 12.00 (or 12.0 depending on C lib)